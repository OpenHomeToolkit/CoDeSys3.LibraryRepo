<?xml version="1.0" encoding="utf-8"?>
<Library Name="CANopenSafetyBase, 3.5.4.0 (3S - Smart Software Solutions GmbH)">
  <Node Name="CalcCCIT16" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="This function generates a 16 bit CRC for &quot;udiByteSize&quot; number of bytes on address &quot;pbyData&quot;.&#xD;&#xA;&quot;wCRC&quot; is the starting seed value and contains the calculated CRC after calling this function.&#xD;&#xA;The CRC generator polynom is: x^16 + x^12 + x^5 + 1 (=CCIT16)&#xD;&#xA;For best performance we use a table driven algorithm which uses a constant table containing 256 words (= 512 Byte).&#xD;&#xA;" ObjectGUID="{cbf8f0b4-89ff-4b3c-9657-cbb82b36e19d}" />
  <Node Name="GlobalConstants" TypeGUID="{ffbfa93a-b94d-45fc-a329-229860183b1d}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" Global constants" IsHidden="true" ObjectGUID="{d42277c3-f8ce-4678-8b8f-1a270132da9a}" />
  <Node Name="Global Constants" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{5a0797f3-60bd-443d-ae11-4375b7b128ee}" />
  <Node Name="Initialization" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{fdf2e836-2fed-485a-ae8c-220befb43358}" />
  <Node Name="Global Variables" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{9d540425-7dff-41f7-8a37-2d995aaea191}" />
  <Node Name="GlobalVariables" TypeGUID="{ffbfa93a-b94d-45fc-a329-229860183b1d}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" IsHidden="true" ObjectGUID="{89c9e982-c369-4f5f-99d0-0b8027185ef9}" />
  <Node Name="ICmpIoDrvParameter" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{ac0cf825-be20-43ce-a80a-9c8b07783b80}" />
  <Node Name="ICmpIoDrv" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{bbb5766d-e6a7-476c-8654-980d2bbe53c3}" />
  <Node Name="MemCopy" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	Function copies memory.&#xD;&#xA;&#xD;&#xA;	This function copies &quot;dwSize&quot; number of bytes&#xD;&#xA; from adress &quot;pbySrc&quot; to &quot;pbyDst&quot;.&#xD;&#xA;&#xD;&#xA; Note, that this function (similar to memcpy in C)&#xD;&#xA; makes no additional checks of input parameters.&#xD;&#xA; The caller has to take care about the validity&#xD;&#xA; of pointers and sizes, passed to this function.&#xD;&#xA;&#xD;&#xA; As the function implements no error handling,&#xD;&#xA; the exact count of &quot;dwSize&quot; bytes is copied &#xD;&#xA; to &quot;pbyDst&quot;.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pbyDst: [VALID_DST_BUFFER]&#xD;&#xA;     :pbySrc: [VALID_SRC_BUFFER]&#xD;&#xA;     :dwSize: [0,1..BUFFER_SIZE]&#xD;&#xA;" ObjectGUID="{406b97f7-1cf8-461f-9bdd-9d22c7cf90e8}" />
  <Node Name="IoCopyIn" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	IoCopyIn should be used for copying data of I/O channels.&#xD;&#xA;&#xD;&#xA; This function copies a specific number of bits from adress&#xD;&#xA; &quot;pbySrc&quot; + &quot;wSrcStartBit&quot; to &quot;pbyDst&quot; + &quot;wDstStartBit&quot;.&#xD;&#xA; Depending on the local byte order of the CPU, this function&#xD;&#xA; takes also care about swapping.&#xD;&#xA; &#xD;&#xA; If possible, the data is copied in bytes. If not, the bits are&#xD;&#xA; copied seperately one after another. In the latter case, the&#xD;&#xA; bit accesses are done atomically, using SysCpuSetBit[/2].&#xD;&#xA;&#xD;&#xA; Note, that this function (similar to memcpy in C)&#xD;&#xA; makes no additional checks of input parameters.&#xD;&#xA; The caller has to take care about the validity&#xD;&#xA; of pointers and sizes, passed to this function.&#xD;&#xA;&#xD;&#xA; As the function implements no error handling,&#xD;&#xA; the exact count of &quot;wSize&quot; bits is copied &#xD;&#xA; to &quot;pbyDst&quot; + &quot;wDstStartBit&quot;.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pbyDst: [VALID_DST_BUFFER]&#xD;&#xA;     :wDstStartBit: [0,1..BUFFER_SIZE_BITS]&#xD;&#xA;     :pbySrc: [VALID_SRC_BUFFER]&#xD;&#xA;     :wSrcStartBit: [0,1..BUFFER_SIZE_BITS]&#xD;&#xA;     :wSize: [0,1..BUFFER_SIZE_BITS]&#xD;&#xA;     :~xTestValid: [TRUE,FALSE]&#xD;&#xA; " ObjectGUID="{e483be17-7323-44c4-944e-2a721453bc22}" />
  <Node Name="MemCopySwap" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	Function copies memory and swaps automatically,&#xD;&#xA; when running on motorolla byte order.&#xD;&#xA;&#xD;&#xA;	This function copies &quot;dwSize&quot; number of bytes&#xD;&#xA; from adress &quot;pbySrc&quot; to &quot;pbyDst&quot;, while the&#xD;&#xA; data is swapped, when running on a CPU with&#xD;&#xA; motorola byte order.&#xD;&#xA;&#xD;&#xA; The range which is swapped is not aligned within&#xD;&#xA; any data type, as this is not known by the function.&#xD;&#xA; The function simply swaps the whole buffer, which&#xD;&#xA; size is defined by the parameter &quot;dwSize&quot;.&#xD;&#xA;&#xD;&#xA; Note, that this function (similar to memcpy in C)&#xD;&#xA; makes no additional checks of input parameters.&#xD;&#xA; The caller has to take care about the validity&#xD;&#xA; of pointers and sizes, passed to this function.&#xD;&#xA;&#xD;&#xA; As the function implements no error handling,&#xD;&#xA; the exact count of &quot;dwSize&quot; bytes is copied &#xD;&#xA; to &quot;pbyDst&quot;.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pbyDst: [VALID_DST_BUFFER]&#xD;&#xA;     :pbySrc: [VALID_SRC_BUFFER]&#xD;&#xA;     :dwSize: [0,1..BUFFER_SIZE]&#xD;&#xA;     :~bMotorola_IN: [TRUE,FALSE] &#xD;&#xA;" ObjectGUID="{83d8b7dd-4ec2-4846-980e-f0650ea72e51}" />
  <Node Name="IoCopyOut" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	IoCopyOut should be used for copying data of I/O channels.&#xD;&#xA;&#xD;&#xA; This function copies a specific number of bits from adress&#xD;&#xA; &quot;pbySrc&quot; + &quot;wSrcStartBit&quot; to &quot;pbyDst&quot; + &quot;wDstStartBit&quot;.&#xD;&#xA; Depending on the local byte order of the CPU, this function&#xD;&#xA; takes also care about swapping.&#xD;&#xA; &#xD;&#xA; If possible, the data is copied in bytes. If not, the bits are&#xD;&#xA; copied seperately one after another. In the latter case, the&#xD;&#xA; bit accesses are done atomically, using SysCpuSetBit[/2].&#xD;&#xA;&#xD;&#xA; Note, that this function (similar to memcpy in C)&#xD;&#xA; makes no additional checks of input parameters.&#xD;&#xA; The caller has to take care about the validity&#xD;&#xA; of pointers and sizes, passed to this function.&#xD;&#xA;&#xD;&#xA; As the function implements no error handling,&#xD;&#xA; the exact count of &quot;wSize&quot; bits is copied &#xD;&#xA; to &quot;pbyDst&quot; + &quot;wDstStartBit&quot;.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pbyDst: [VALID_DST_BUFFER]&#xD;&#xA;     :wDstStartBit: [0,1..BUFFER_SIZE_BITS]&#xD;&#xA;     :pbySrc: [VALID_SRC_BUFFER]&#xD;&#xA;     :wSrcStartBit: [0,1..BUFFER_SIZE_BITS]&#xD;&#xA;     :wSize: [0,1..BUFFER_SIZE_BITS]&#xD;&#xA;     :~xTestValid: [TRUE,FALSE]&#xD;&#xA;" ObjectGUID="{3476db81-3803-4bd6-83d9-15dd269271b5}" />
  <Node Name="MemCmp" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	MemCmp compares two memory buffers.&#xD;&#xA;&#xD;&#xA; This function compares the data at &quot;pbyMem1&quot;&#xD;&#xA; of &quot;dwSize&quot; bytes with the data at &quot;pbyMem2&quot;.&#xD;&#xA; &#xD;&#xA; If the data is fully equal, the function&#xD;&#xA; returns TRUE. Otherwise the function returns&#xD;&#xA; FALSE.&#xD;&#xA;&#xD;&#xA; If dwSize is 0, the function returns TRUE,&#xD;&#xA; as zero compared bytes are always equal. &#xD;&#xA;&#xD;&#xA; Note, that this function (similar to memcmp in C)&#xD;&#xA; makes no additional checks of input parameters.&#xD;&#xA; The caller has to take care about the validity&#xD;&#xA; of pointers and sizes, passed to this function.&#xD;&#xA;&#xD;&#xA; As the function implements no error handling,&#xD;&#xA; the exact count of &quot;dwSize&quot; bytes is compared.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pbyMem1: [VALID_DST_BUFFER]&#xD;&#xA;     :pbyMem2: [VALID_SRC_BUFFER]&#xD;&#xA;     :dwSize: [0,1..BUFFER_SIZE]&#xD;&#xA;     :~dwErrorPos_IN: [0,1..BUFFER_SIZE]&#xD;&#xA; " ObjectGUID="{759a260e-091a-4d19-9990-7148f57d4934}" />
  <Node Name="InverseMemCopy" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	Function copies memory by inversing the bits.&#xD;&#xA;&#xD;&#xA;	This function copies &quot;dwSize&quot; number of bytes&#xD;&#xA; from adress &quot;pbySrc&quot; to &quot;pbyDst&quot;, while every&#xD;&#xA; single bit within this buffer is inverted.&#xD;&#xA;&#xD;&#xA; Note, that this function (similar to memcpy in C)&#xD;&#xA; makes no additional checks of input parameters.&#xD;&#xA; The caller has to take care about the validity&#xD;&#xA; of pointers and sizes, passed to this function.&#xD;&#xA;&#xD;&#xA; As the function implements no error handling,&#xD;&#xA; the exact count of &quot;dwSize&quot; bytes is copied &#xD;&#xA; to &quot;pbyDst&quot;.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pbyDst: [VALID_DST_BUFFER]&#xD;&#xA;     :pbySrc: [VALID_SRC_BUFFER]&#xD;&#xA;     :dwSize: [0,1..BUFFER_SIZE]&#xD;&#xA;" ObjectGUID="{deb85844-9f7b-4e9c-9ee6-81e575af9963}" />
  <Node Name="Memory Functions" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{dd274f14-dd00-44e3-a05f-8eddc563f179}" />
  <Node Name="00000000-0000-0000-0000-000000000000|D:\CoDeSys\LibrariesV3\trunk\Intern\CAA\CAA Template\3.5.2.0 draft\Placeholder.xml" TypeGUID="{9001d745-b9c5-4d77-90b7-b29c3f77a23b}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{0c414bea-9ea7-42e9-ad46-c1992bd6dc54}" />
  <Node Name="00000000-0000-0000-0000-000000000000|D:\CoDeSys\LibrariesV3\trunk\Intern\CAA\CAA Template\3.2.0.3 draft\Prefix.pdf" TypeGUID="{9001d745-b9c5-4d77-90b7-b29c3f77a23b}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{eb5edfb0-5276-4130-9805-e0374d98bd90}" />
  <Node Name="DWORD_SEQ_LET" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	Function Compares two 32 bit Timestamps.&#xD;&#xA;&#xD;&#xA; It checks if &quot;udiLeft &lt;= udiRight&quot;, while&#xD;&#xA; it takes care about wrap arounds at the 32bit&#xD;&#xA; boundaries. If so, the function returns TRUE,&#xD;&#xA; otherwise it returns FALSE.&#xD;&#xA;&#xD;&#xA;	Note, that this function only allows difference&#xD;&#xA; less than 16#80000000, as this limit is used&#xD;&#xA; to determine if a value is smaller or bigger&#xD;&#xA; than the other.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :udiLeft: [0..2147483647,2147483648..4294967295]&#xD;&#xA;     :udiRight: [0..2147483647,2147483648..4294967295]&#xD;&#xA;" ObjectGUID="{8bc6a2e3-f51b-444c-ba3c-b39b8f80af6c}" />
  <Node Name="Time Functions" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{e86df919-01a7-42bd-96b5-3d9421681094}" />
  <Node Name="00000000-0000-0000-0000-000000000000|D:\CoDeSys\LibrariesV3\trunk\Intern\CAA\CAA Template\3.4.0.0 draft\Placeholder.xml" TypeGUID="{9001d745-b9c5-4d77-90b7-b29c3f77a23b}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{5eef32c3-f0f3-4ec8-8b19-c6fda6dcba39}" />
  <Node Name="CheckInverseData" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	Checks if one buffer contains the inverse&#xD;&#xA; of another.&#xD;&#xA;&#xD;&#xA; This function compares the data at &quot;pbyData1&quot;&#xD;&#xA; of &quot;udiLength&quot; bytes with the data at &quot;pbyData2&quot;.&#xD;&#xA; &#xD;&#xA; If the data is the exact inverse, the function&#xD;&#xA; returns TRUE. Otherwise the function returns&#xD;&#xA; FALSE.&#xD;&#xA;&#xD;&#xA; If dwSize is 0, the function returns FALSE,&#xD;&#xA; as zero compared bytes can't be inverse. &#xD;&#xA;&#xD;&#xA; Note, that this function (similar to memcmp in C)&#xD;&#xA; makes no additional checks of input parameters.&#xD;&#xA; The caller has to take care about the validity&#xD;&#xA; of pointers and sizes, passed to this function.&#xD;&#xA;&#xD;&#xA; As the function implements no error handling,&#xD;&#xA; the exact count of &quot;udiLength&quot; bytes is compared.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pbyData1: [VALID_DST_BUFFER]&#xD;&#xA;     :pbyData2: [VALID_SRC_BUFFER]&#xD;&#xA;     :udiLength: [0,1..BUFFER_SIZE]&#xD;&#xA;     :~dwErrorPos_IN: [0,1..BUFFER_SIZE]&#xD;&#xA;" ObjectGUID="{868ea6c7-e56f-451b-b1c3-c49101b75e3b}" />
  <Node Name="DWORD_SEQ_LT" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	Function Compares two 32 bit Timestamps.&#xD;&#xA;&#xD;&#xA; It checks if &quot;udiLeft &lt; udiRight&quot;, while&#xD;&#xA; it takes care about wrap arounds at the 32bit&#xD;&#xA; boundaries. If so, the function returns TRUE,&#xD;&#xA; otherwise it returns FALSE.&#xD;&#xA;&#xD;&#xA;	Note, that this function only allows difference&#xD;&#xA; less than 16#80000000, as this limit is used&#xD;&#xA; to determine if a value is smaller or bigger&#xD;&#xA; than the other.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :udiLeft: [0..2147483647,2147483648..4294967295]&#xD;&#xA;     :udiRight: [0..2147483647,2147483648..4294967295]&#xD;&#xA; " ObjectGUID="{56ecb728-262c-4388-a495-a9912e0d79e8}" />
  <Node Name="Validation Checks" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{3f482895-3c79-4a2c-97a7-0e3454503625}" />
  <Node Name="CheckReceivedSRDO" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment="	Check if an SRDO contains valid data.&#xD;&#xA;&#xD;&#xA; This function is getting a pointer to SRDO data&#xD;&#xA; from the safety-, as well as from the unsafe&#xD;&#xA; stack. Both are necessary to check all requirements&#xD;&#xA; which are specified for the consistency of an&#xD;&#xA; SRDO.&#xD;&#xA;&#xD;&#xA; If there was an error or the SRDO was not, yet,&#xD;&#xA; completely received, the function returns FALSE.&#xD;&#xA; Only if it was received completely, and the&#xD;&#xA; constistency was successfully checked, it returns&#xD;&#xA; TRUE.&#xD;&#xA;&#xD;&#xA; If there was an error, this is indicated by the&#xD;&#xA; additional output xError, which becomes TRUE&#xD;&#xA; only in this case.&#xD;&#xA;&#xD;&#xA; If the parameter pUnsafeSRDO is NULL, the data&#xD;&#xA; is not fully checked for consistency, but only&#xD;&#xA; the SCT timing is checked. This way, an SCT&#xD;&#xA; expiration can be detected here, even if&#xD;&#xA; the caller didn't receive anything, yet.&#xD;&#xA;&#xD;&#xA; SCT Checks are only done when the SRDO is&#xD;&#xA; active. Inactive means, that the safety link&#xD;&#xA; is not up, yet. So when it's inactive, we have&#xD;&#xA; no reference time to check against.&#xD;&#xA;&#xD;&#xA; Generally the following checks are implemented:&#xD;&#xA;&#xD;&#xA; - Config SRDO not linked&#xD;&#xA;   If the safe SRDO has no config linked to it,&#xD;&#xA;   the following output is set:&#xD;&#xA;   - result := FALSE&#xD;&#xA;   - xError := TRUE&#xD;&#xA;   - SRDO_STATE := INTERNAL_ERROR&#xD;&#xA;&#xD;&#xA; - SCT Timeout based on current time&#xD;&#xA;   The last receive time of the SRDO is compared&#xD;&#xA;   against the current system time, passed in&#xD;&#xA;   the parameter dwCurrentTime. If the difference&#xD;&#xA;   expires the configured SCT the following outputs&#xD;&#xA;   are set:&#xD;&#xA;   - result := FALSE&#xD;&#xA;   - xError := TRUE&#xD;&#xA;   - SRDO_STATE := SCT_TIMEOUT&#xD;&#xA;&#xD;&#xA; - SRVT Timeout based on current time&#xD;&#xA;   If SRDO1 was already received, but SRDO2 not, yet,&#xD;&#xA;   the SRVT is calculated as the difference between&#xD;&#xA;   the recieve time of SRDO1 and the current time.&#xD;&#xA;   If the SRVT expired, the following outputs are set:&#xD;&#xA;   - result := FALSE&#xD;&#xA;   - xError := TRUE&#xD;&#xA;   - SRDO_STATE := SRVT_TIMEOUT&#xD;&#xA;&#xD;&#xA; - Sequence Consistency&#xD;&#xA;   SRDO2 should be newer or equally old as SRDO1.&#xD;&#xA;   Further more, the last receive time of the SRDOs&#xD;&#xA;   has to be older than the current receive time of&#xD;&#xA;   the SRDO. &#xD;&#xA;   If this is not the case, the following outputs&#xD;&#xA;   are set:&#xD;&#xA;   - result := FALSE&#xD;&#xA;   - xError := TRUE&#xD;&#xA;   - SRDO_STATE := RECEIVE_ERROR&#xD;&#xA;&#xD;&#xA; - SRDO Header Consistency&#xD;&#xA;   Check if:&#xD;&#xA;   - the length is in a valid range between 1 and 8&#xD;&#xA;   - the length is equal between SRDO1 and SRDO2&#xD;&#xA;   - the cobIDs of SRDO1 and SRDO2 are matching the&#xD;&#xA;     configured cobIDs &#xD;&#xA;   If this is not the case, the following outputs&#xD;&#xA;   are set:&#xD;&#xA;   - result := FALSE&#xD;&#xA;   - xError := TRUE&#xD;&#xA;   - SRDO_STATE := DATA_ERROR&#xD;&#xA;&#xD;&#xA; - SRDO Data Consistency&#xD;&#xA;   Check if the data of SRDO2 is the&#xD;&#xA;   inverse equivalent of SRDO1. If it's&#xD;&#xA;   not, the following output is set:&#xD;&#xA;   - result := FALSE&#xD;&#xA;   - xError := TRUE&#xD;&#xA;   - SRDO_STATE := DATA_ERROR&#xD;&#xA;&#xD;&#xA; - SCT Timeout&#xD;&#xA;   The last receive time of the SRDO is compared&#xD;&#xA;   against the currently checked SRDO. If the difference&#xD;&#xA;   expires the configured SCT the following outputs&#xD;&#xA;   are set:&#xD;&#xA;   - result := FALSE&#xD;&#xA;   - xError := TRUE&#xD;&#xA;   - SRDO_STATE := SCT_TIMEOUT&#xD;&#xA;&#xD;&#xA; - SRVT Timeout&#xD;&#xA;   The SRVT is calculated as the difference between&#xD;&#xA;   the recieve time of SRDO1 and the receive time of&#xD;&#xA;   SRDO2. If the SRVT expired, the following outputs&#xD;&#xA;   are set:&#xD;&#xA;   - result := FALSE&#xD;&#xA;   - xError := TRUE&#xD;&#xA;   - SRDO_STATE := SRVT_TIMEOUT&#xD;&#xA;&#xD;&#xA; The following operation modes are implemented,&#xD;&#xA; doing the corresponding checks:&#xD;&#xA;&#xD;&#xA; - pUnsafeSRDO = 0&#xD;&#xA;   - SCT Timeout based on current time&#xD;&#xA;&#xD;&#xA; - SRDO1 or SRDO2 not fully received&#xD;&#xA;   - SCT Timeout based on current time&#xD;&#xA;   - SRVT Timeout based on current time&#xD;&#xA;&#xD;&#xA; - SRDO1 and SRDO2 fully received&#xD;&#xA;   - Sequence Consistency&#xD;&#xA;   - SRDO Header Consistency&#xD;&#xA;   - SRDO Data Consistency&#xD;&#xA;   - SCT Timeout&#xD;&#xA;   - SRVT Timeout&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pSafeSRDO: [NULL,VALID_SAFE_SRDO]&#xD;&#xA;     :pUnsafeSRDO: [NULL,VALID_UNSAFE_SRDO]&#xD;&#xA;     :dwCurrentTime: [CURRENT_TIME_PAST,CURRENT_TIME_FUTURE,CURRENT_TIME_EXPIRED]&#xD;&#xA;     :~SRDO1_IN: [SRDO1_VALID,SRDO1_INCONSISTENT,SRDO1_NOT_RECEIVED,SRDO1_SEQUENCE_ERROR,SRDO1_DATA_ERROR,SRDO1_SCT_TIMEOUT]&#xD;&#xA;     :~SRDO2_IN: [SRDO2_VALID,SRDO2_INCONSISTENT,SRDO2_NOT_RECEIVED,SRDO2_SEQUENCE_ERROR,SRDO2_DATA_ERROR,SRDO2_SRVT_TIMEOUT,SRDO2_SCT_TIMEOUT]&#xD;&#xA;     :~SRDO_STATE_IN: [SRDO_STATE_ACTIVE,SRDO_STATE_INACTIVE]&#xD;&#xA;     :~SRDO_STATE_OUT: [SRDO_STATE_ACTIVE,SRDO_STATE_RECEIVE_ERROR,SRDO_STATE_DATA_ERROR,SRDO_STATE_SCT_TIMEOUT,SRDO_STATE_SRVT_TIMEOUT]&#xD;&#xA;     :~xError: [TRUE,FALSE]&#xD;&#xA;" ObjectGUID="{7541abc1-ef6a-4226-b323-42f2a5d005aa}" />
  <Node Name="IBase" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{aef9bbd6-a9a2-4dc6-a3d9-a58946b6930d}" />
  <Node Name="CheckConfigSRDO" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Function does consistency checks of a IOConfig SRDO structure.&#xD;&#xA;&#xD;&#xA; Returns FALSE if an inconsistency is detected and TRUE,&#xD;&#xA; if the data is consistent.&#xD;&#xA;&#xD;&#xA; The following errors are checked:&#xD;&#xA; &#xD;&#xA; - eDirection &gt; 2&#xD;&#xA; &#xD;&#xA; - dwCOBID1 is even&#xD;&#xA; &#xD;&#xA; - dwCOBID2 is odd &#xD;&#xA; &#xD;&#xA; - SCT is not set&#xD;&#xA; &#xD;&#xA; - SRVT is not set&#xD;&#xA; &#xD;&#xA; - RefreshTime is not set&#xD;&#xA; &#xD;&#xA; - SRDO length is 0&#xD;&#xA; &#xD;&#xA; - SRDO is larger than 8&#xD;&#xA; &#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :ConfigSRDO: [VALID_SRDO_CONFIG]&#xD;&#xA;     :~ConfigSRDO_eDirection_IN: [0,1,2,3]&#xD;&#xA;     :~ConfigSRDO_dwCOBID1_IN: [VALID_COBID_ODD,VALID_COBID_EVEN]&#xD;&#xA;     :~ConfigSRDO_dwCOBID2_IN: [VALID_COBID_ODD,VALID_COBID_EVEN]&#xD;&#xA;     :~ConfigSRDO_uiSCT_IN: [0..4294967295]&#xD;&#xA;     :~ConfigSRDO_bySRVT_IN: [0..255]&#xD;&#xA;     :~ConfigSRDO_uiRefreshTime_IN: [0..4294967295]&#xD;&#xA;     :~ConfigSRDO_byLength_IN: [0,1..8,9]&#xD;&#xA;" ObjectGUID="{cb75d72d-9e61-4897-bdbd-02fe64bb57fe}" />
  <Node Name="CANopenSafetyBase" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" ObjectGUID="{d2af3368-a598-4326-9c54-3460a23122b7}">
    <Node Name="Initialize" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This is an implicit function.&#xD;&#xA;&#xD;&#xA; It is called by the &quot;Device Object&quot;&#xD;&#xA; to inform the implicitely generated&#xD;&#xA; function blocks, because of which&#xD;&#xA; connector they where instantiated.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: This error code is always returned.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :wModuleType: [INVALID_MODULETYPE,VALID_MODULETYPE]&#xD;&#xA;     :dwInstance: [0..NUM_OF_INSTANCES]&#xD;&#xA;     :pConnector: [INVALID_CONNECTOR,VALID_CONNECTOR]&#xD;&#xA;" IsHidden="true" ObjectGUID="{91c734b9-f019-4afa-aca4-b694f5b2dd6b}" />
    <Node Name="MeasureTime" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Calculate the last cycle time in us&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: No errors occured.&#xD;&#xA;&#xD;&#xA; - ERR_FAILED: Not able to get current time.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :~curTime_IN: [0..4294967295]&#xD;&#xA;     :~curTime_OLD: [0..4294967295]&#xD;&#xA;" ObjectGUID="{807a4899-2b01-4ae7-a23c-eacedd1d894a}" />
    <Node Name="InitExchange" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Initialize the safety exchange memory.&#xD;&#xA;&#xD;&#xA; The communication between safe and unsafe&#xD;&#xA; stack is done via shared memory, the so&#xD;&#xA; called &quot;safety exchange&quot;.&#xD;&#xA;&#xD;&#xA; The unsafe stack stores a pointer to&#xD;&#xA; the safety exchange into an IoConfigParameter.&#xD;&#xA; InitExchange reads this pointer.&#xD;&#xA;&#xD;&#xA; The function checks the placement of the exchange&#xD;&#xA; to make sure, that the safety stack doesn't overwrite&#xD;&#xA; safe data, because of a bug in the unsafe stack.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: No errors occured.&#xD;&#xA;&#xD;&#xA; - ERR_FAILED: Failed to initialize exchange memory.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :~pExchange_IN: [INVALID_EXCHANGE,VALID_EXCHANGE]&#xD;&#xA;" IsHidden="true" ObjectGUID="{d004a940-28d7-4417-aa9e-5820ff2b680a}" />
    <Node Name="IoDrvUpdateConfiguration" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" IoDrvUpdateConfiguration is called on a new download or reset.&#xD;&#xA;&#xD;&#xA; Update or reset configuration&#xD;&#xA;&#xD;&#xA; This function is called when the I/O driver is&#xD;&#xA; initialized as well as when it is cleaned up.&#xD;&#xA;&#xD;&#xA; On cleanup, the parameter pConnectorList is zero.&#xD;&#xA;&#xD;&#xA; This function identifies the byte order of the system.&#xD;&#xA; Reading the safety configuration is done by derived FB.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: No errors occured.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pConnectorList: [VALID_CONNECTOR_LIST,INVALID_CONNECTOR_LIST]&#xD;&#xA;     :nCount: [0,VALID_CONNECTOR_LIST_COUNT]&#xD;&#xA;     :~xSRDOValid_IN: [YES,NO,NONE]&#xD;&#xA;     :~CRC_IN: [VALID_CRC,INVALID_CRC1,INVALID_CRC2]&#xD;&#xA;     :~UnsafeConfigSRDO_IN: [NULL,VALID_CONFIG_SRDO,INVALID_CONFIG_SRDO]&#xD;&#xA;     :~result: [ERR_FAILED,ERR_OK,ERR_PARAMETER]&#xD;&#xA;" IsHidden="true" ObjectGUID="{0bafc962-6841-4286-b55a-d697972e25d0}" />
    <Node Name="IoDrvReadParameter" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Reading Parameters is not supported&#xD;&#xA; by the safety layer.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_NOTIMPLEMENTED: As this function is &#xD;&#xA;   not implemented, it always returns this&#xD;&#xA;   error code.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pConnector: [INVALID_CONNECTOR,VALID_CONNECTOR]&#xD;&#xA;     :pParameter: [INVALID_PARAMETER,VALID_PARAMETER]&#xD;&#xA;     :pData: [NULL,VALID_PARAMETER_DATA_POINTER]&#xD;&#xA;     :dwBitSize: [0..7,8..15,16..32]&#xD;&#xA;     :dwBitOffset: [0..7,8..15,16..32]&#xD;&#xA;     :~Result_OUT: [ERR_OK,ERR_FAILED,ERR_NOTIMPLEMENTED]&#xD;&#xA;" IsHidden="true" ObjectGUID="{45d9c6b6-8755-4720-9f2d-610aa5365c14}" />
    <Node Name="IoDrvWriteParameter" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Writing Parameters is not supported&#xD;&#xA; by the safety layer.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_NOTIMPLEMENTED: As this function is &#xD;&#xA;   not implemented, it always returns this&#xD;&#xA;   error code.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pConnector: [INVALID_CONNECTOR,VALID_CONNECTOR]&#xD;&#xA;     :pParameter: [INVALID_PARAMETER,VALID_PARAMETER]&#xD;&#xA;     :pData: [NULL,VALID_PARAMETER_DATA_POINTER]&#xD;&#xA;     :dwBitSize: [0..7,8..15,16..32]&#xD;&#xA;     :dwBitOffset: [0..7,8..15,16..32]&#xD;&#xA;     :~Result_OUT: [ERR_OK,ERR_FAILED,ERR_NOTIMPLEMENTED]&#xD;&#xA;" IsHidden="true" ObjectGUID="{428a4bf1-f2b0-4ca1-ba9c-ec589df63d91}" />
    <Node Name="IoDrvScanModules" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Scanning for devices is not supported&#xD;&#xA; by the safety layer.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_NOTIMPLEMENTED: As this function is &#xD;&#xA;   not implemented, it always returns this&#xD;&#xA;   error code.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pConnector: [VALID_CONNECTOR,INVALID_CONNECTOR]&#xD;&#xA;     :ppConnectorList: [INVALID_CONNECTOR_LIST_POINTER,VALID_CONNECTOR_LIST_POINTER]&#xD;&#xA;     :pnCount: [INVALID_COUNT_POINTER,VALID_COUNT_POINTER]&#xD;&#xA;     :~Result_OUT: [ERR_OK,ERR_FAILED,ERR_NOTIMPLEMENTED]&#xD;&#xA;" IsHidden="true" ObjectGUID="{4da419d4-e4da-463b-912f-f1e705cbeae2}" />
    <Node Name="IoDrvReadInputs" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Copy the I/O data from the safe PDO buffers&#xD;&#xA; into the applications I/O memory or directly&#xD;&#xA; the variables of the application.&#xD;&#xA;&#xD;&#xA; Note, that this function makes&#xD;&#xA; no additional checks of pointer consistency.&#xD;&#xA; The IoMgr takes care about the validity&#xD;&#xA; of pointers and structures, passed to or &#xD;&#xA; used in this function.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: Successfully read inputs.&#xD;&#xA;&#xD;&#xA; - ERR_PARAMETER: Invalid parameters.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pConnectorMapList: [VALID_CONNECTOR_MAP,INVALID_CONNECTOR_MAP]&#xD;&#xA;     :nCount: [0,VALID_CONNECTOR_MAP_SIZE]&#xD;&#xA;     :~pParameter_wLen_IN: [8,16,32]&#xD;&#xA;     :~pChannelMap_wIecAddressBitOffset_IN: [0,1,8]&#xD;&#xA;     :~pChannelMap_wParameterBitOffset_IN: [0,1,8]&#xD;&#xA;     :~pChannelMap_wSize_IN: [CHANNEL_SIZE_BIT,CHANNEL_SIZE_FULL]&#xD;&#xA;     :~pParameter_dwDriverSpecific_wSrcStartBit_IN: [0,8,16]&#xD;&#xA;     :~bMotorola_IN: [TRUE,FALSE] &#xD;&#xA;     :~xTestValid: [TRUE,FALSE]&#xD;&#xA;     :~result: [ERR_OK,ERR_PARAMETER]&#xD;&#xA;" IsHidden="true" ObjectGUID="{8352a441-ba57-418e-8a4b-fb6cb58fc4e0}" />
    <Node Name="IoDrvWriteOutputs" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Copy the I/O data from the applications&#xD;&#xA; I/O memory or directly the variables of&#xD;&#xA; the application into the safe PDO buffers.&#xD;&#xA;&#xD;&#xA; Note, that this function makes&#xD;&#xA; no additional checks of pointer consistency.&#xD;&#xA; The IoMgr takes care about the validity&#xD;&#xA; of pointers and structures, passed to or &#xD;&#xA; used in this function.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: No errors occured.&#xD;&#xA;&#xD;&#xA; - ERR_PARAMETER: Invalid pConnectorMapList&#xD;&#xA;   or nCount parameter. &#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pConnectorMapList: [VALID_CONNECTOR_MAP,INVALID_CONNECTOR_MAP]&#xD;&#xA;     :nCount: [0,VALID_CONNECTOR_MAP_SIZE]&#xD;&#xA;     :~pParameter_wLen_IN: [8,16,32]&#xD;&#xA;     :~pChannelMap_wIecAddressBitOffset_IN: [0,1,8]&#xD;&#xA;     :~pChannelMap_wParameterBitOffset_IN: [0,1,8]&#xD;&#xA;     :~pChannelMap_wSize_IN: [CHANNEL_SIZE_BIT,CHANNEL_SIZE_FULL]&#xD;&#xA;     :~pParameter_dwDriverSpecific_wDstStartBit_IN: [0,8,16]&#xD;&#xA;     :~bMotorola_IN: [TRUE,FALSE] &#xD;&#xA;     :~xTestValid: [TRUE,FALSE]&#xD;&#xA;     :~result: [ERR_OK,ERR_PARAMETER]&#xD;&#xA;" IsHidden="true" ObjectGUID="{b85bf9f5-b4db-4a7a-b09c-d47ecd655926}" />
    <Node Name="IoDrvGetInfo" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function is called by the I/O&#xD;&#xA; manager, to get the driver informations.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: Successfully returned driver information.&#xD;&#xA;&#xD;&#xA; - ERR_PARAMETER: ppInfo was NULL.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :ppInfo: [NULL,VALID_INFO_POINTER]&#xD;&#xA;     :~pInfo_OUT: [NULL,VALID_INFO_POINTER]&#xD;&#xA;     :~Result_OUT: [ERR_PARAMETER,ERR_OK]&#xD;&#xA;" IsHidden="true" ObjectGUID="{467d38f1-9066-42e3-8d5c-f6af4250720b}" />
    <Node Name="QueryInterface" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function is called by the I/O&#xD;&#xA; manager, to get the interface pointers&#xD;&#xA; for the different interfaces, that are&#xD;&#xA; implemented by this FB.&#xD;&#xA;&#xD;&#xA; The interface pointers are saved in local&#xD;&#xA; variables, that are initialized in FB_Init.&#xD;&#xA;&#xD;&#xA; The compiler is already storing the intended&#xD;&#xA; interface pointer, because of the type of&#xD;&#xA; those local variables.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: Successfully returned instance pointers.&#xD;&#xA;&#xD;&#xA; - ERR_FAILED: Failed returning instance pointers.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :iid: [ITFID_ICmpIoDrv,ITFID_ICmpIoDrvParameter,ITFID_INVALID]&#xD;&#xA;     :pResult: [NULL,VALID_PRESULT]&#xD;&#xA;     :~Result_OUT: [ERR_OK]&#xD;&#xA;     :~Interface_OUT: [VALID_ITF_IODRV,VALID_ITF_IODRVPARAMETER]&#xD;&#xA;" IsHidden="true" ObjectGUID="{d8fef178-fad1-49e6-a3e7-2776bb357e4b}" />
    <Node Name="IoDrvUpdateMapping" TypeGUID="{f8a58466-d7f6-439f-bbb8-d4600e41d099}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Update Mapping is not implemented&#xD;&#xA; by the safety layer. But this function&#xD;&#xA; returns ERR_OK anyway, because&#xD;&#xA; nothing needs to be done.&#xD;&#xA;&#xD;&#xA; The following error codes may be returned:&#xD;&#xA;&#xD;&#xA; - ERR_OK: This error code is always returned.&#xD;&#xA;&#xD;&#xA; .. cds:ranges::&#xD;&#xA;&#xD;&#xA;     :pTaskMapList: [INVALID_TASK_MAP_LIST,VALID_TASK_MAP_LIST]&#xD;&#xA;     :nCount: [0,VALID_TASK_MAP_LIST_COUNT]&#xD;&#xA;     :~Result_OUT: [ERR_OK,ERR_FAILED]&#xD;&#xA;" IsHidden="true" ObjectGUID="{0e06d826-9995-41eb-8b33-94afeebf5a35}" />
  </Node>
  <Node Name="Function Blocks" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{8ad6e219-0844-4a03-9d00-6077c0ff578e}" />
  <Node Name="CANopenSafetyBase" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{b9741afd-ccd3-4994-99f4-7d8a942952f6}" />
  <Node Name="Project Settings" TypeGUID="{8753fe6f-4a22-4320-8103-e553c4fc8e04}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{6470a90f-b7cb-43ac-9ae5-94b2338b4573}" />
  <Node Name="Library Manager" TypeGUID="{adb5cb65-8e1d-4a00-b70a-375ea27582f3}" EmbeddedTypeGUIDs="" ObjectGUID="{8c1463b5-02f2-427d-bd06-9e39d42fcbff}" />
  <Node Name="Project Information" TypeGUID="{085afe48-c5d8-4ea5-ab0d-b35701fa6009}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{11c0fc3a-9bcf-4dd8-ac38-efb93363e521}" />
  <Node Name="Functions" TypeGUID="{738bea1e-99bb-4f04-90bb-a7a567e74e3a}" EmbeddedTypeGUIDs="" ProvidesLanguageModel="false" ObjectGUID="{a1970cad-fb7e-4f32-9f9c-fd8f237326f9}" />
</Library>